package tfvars

import (
	"fmt"
	"regexp"
	"sort"
	"strconv"
	"strings"
)

// Variable represents a Terraform variable assignment
type Variable struct {
	Name  string
	Value string
	Type  VariableType
}

type VariableType int

const (
	StringType VariableType = iota
	NumberType
	BoolType
	ObjectType
	ArrayType
)

// ParseTfvars parses a .tfvars file content and returns variables
func ParseTfvars(content []byte) ([]Variable, error) {
	content_str := string(content)
	lines := strings.Split(content_str, "\n")

	var variables []Variable
	var currentVar *Variable
	var objectDepth int
	var arrayDepth int

	for _, line := range lines {
		line = strings.TrimSpace(line)

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// If we're inside an object or array, continue building it
		if currentVar != nil && (objectDepth > 0 || arrayDepth > 0) {
			currentVar.Value += "\n" + line

			// Count braces and brackets
			objectDepth += strings.Count(line, "{") - strings.Count(line, "}")
			arrayDepth += strings.Count(line, "[") - strings.Count(line, "]")

			// If we've closed all braces/brackets, we're done with this variable
			if objectDepth <= 0 && arrayDepth <= 0 {
				variables = append(variables, *currentVar)
				currentVar = nil
				objectDepth = 0
				arrayDepth = 0
			}
			continue
		}

		// Match variable assignment: name = value
		re := regexp.MustCompile(`^(\w+)\s*=\s*(.*)$`)
		matches := re.FindStringSubmatch(line)

		if len(matches) != 3 {
			continue
		}

		name := matches[1]
		valueStr := strings.TrimSpace(matches[2])

		// Determine variable type and handle multi-line values
		varType, isMultiLine := determineVariableType(valueStr)

		if isMultiLine {
			// Start collecting multi-line value
			currentVar = &Variable{
				Name:  name,
				Value: valueStr,
				Type:  varType,
			}

			// Count initial braces/brackets
			objectDepth = strings.Count(valueStr, "{") - strings.Count(valueStr, "}")
			arrayDepth = strings.Count(valueStr, "[") - strings.Count(valueStr, "]")

			// If it's not actually multi-line (all braces/brackets closed)
			if objectDepth <= 0 && arrayDepth <= 0 {
				variables = append(variables, *currentVar)
				currentVar = nil
			}
		} else {
			// Single-line variable
			variables = append(variables, Variable{
				Name:  name,
				Value: valueStr,
				Type:  varType,
			})
		}
	}

	return variables, nil
}

// determineVariableType determines the type of a variable from its value
func determineVariableType(value string) (VariableType, bool) {
	value = strings.TrimSpace(value)

	// Check for objects
	if strings.HasPrefix(value, "{") {
		isMultiLine := !strings.HasSuffix(value, "}")
		return ObjectType, isMultiLine
	}

	// Check for arrays
	if strings.HasPrefix(value, "[") {
		isMultiLine := !strings.HasSuffix(value, "]")
		return ArrayType, isMultiLine
	}

	// Check for strings (quoted)
	if strings.HasPrefix(value, "\"") && strings.HasSuffix(value, "\"") {
		return StringType, false
	}

	// Check for booleans
	if value == "true" || value == "false" {
		return BoolType, false
	}

	// Check for numbers
	if _, err := strconv.ParseFloat(value, 64); err == nil {
		return NumberType, false
	}

	// Default to string
	return StringType, false
}

// MergeVariables merges multiple sets of variables, with later values overriding earlier ones
func MergeVariables(variableSets ...[]Variable) []Variable {
	merged := make(map[string]Variable)

	// Process each set in order
	for _, vars := range variableSets {
		for _, variable := range vars {
			merged[variable.Name] = variable
		}
	}

	// Convert back to slice and sort for consistent output
	result := make([]Variable, 0, len(merged))
	for _, variable := range merged {
		result = append(result, variable)
	}

	// Sort by variable name for consistent output
	sort.Slice(result, func(i, j int) bool {
		return result[i].Name < result[j].Name
	})

	return result
}

// GenerateTfvars generates a .tfvars file content from variables
func GenerateTfvars(variables []Variable, environmentName string) string {
	var builder strings.Builder

	builder.WriteString(fmt.Sprintf("# Combined variables for environment: %s\n", environmentName))
	builder.WriteString("# Generated by tivor\n\n")

	for _, variable := range variables {
		builder.WriteString(fmt.Sprintf("%s = %s\n", variable.Name, variable.Value))
	}

	return builder.String()
}
